---
import { lex } from "../lexer/lexer";
const {code, steps} = Astro.props;

/** 
 * Performs the following:
 * - Removes the first & last line, if they are empty
 * - Picks the indentation level from the first non-white line
 * - Dedents the following lines
*/
function trimAndDedent(input: string): Array<string> {
    let lines = input.split("\n");

    // Remove empty lines at the start
    while (lines[0] === "") {
        lines = lines.slice(1);
    }

    // Get indentation level
    let indentationLevel = 0;
    for (const char of lines[0]!) {
        if (char === " ") {
            indentationLevel += 1;
        } else {
            break;
        }
    }

    // Enforce indentation, or trim
    for (let i = 0; i < lines.length; i += 1) {
        // If the line is empty, continue
        const characters = lines[i]!.split("");
        if (characters.length === 0) {
            continue;
        }

        // If all characters are whitespace, append just a newline
        const nonWhitespace = characters.find((x) => x !== " ");
        if (nonWhitespace === undefined) {
            lines[i] = "";
            continue;
        }

        // Enforce indentation
        if (characters.length < indentationLevel) {
            throw new Error("Invalid indentation while parsing THP code: " + lines[i]);
        }
        let currentIndentation = 0;
        for (const c of characters) {
            if (c === " ") { currentIndentation += 1 }
            else {break;}
        }
        if (currentIndentation < indentationLevel) {
            throw new Error("Invalid indentation while parsing THP code: " + lines[i]);
        }

        lines[i] = characters.slice(4).join("");
    }


    // Remove empty lines at the end
    let endPosition = lines.length - 1;
    while (true) {
        if (lines[endPosition] === "") {
            lines = lines.slice(0, -1);
            endPosition -= 1;
        } else {
            break;
        }
    }

    return lines;
}

function highlightCode(lines: Array<string>): string {
    let outLines: Array<string> = [];

    for (const [idx, line] of lines.entries()) {
        const tokens = lex(line);
        const lineArray = [
            `<div class=\"inline-block w-full\" :class=\"line === ${idx + 1}? 'bg-green-200 dark:bg-green-900': ''\">`
        ];

        for (const token of tokens) {
            if (token.token_type !== "") {
                lineArray.push(`<span class="token ${token.token_type}">${token.v}</span>`);
            } else {
                lineArray.push(token.v);
            }
        }
        lineArray.push("</div>");

        outLines.push(lineArray.join(""));
    }

    return outLines.join("\n");
}

const codeHtml = highlightCode(trimAndDedent(code));
---

<div class="bg-black text-white rounded"
    x-data={`{
        line: 0,
        stdout: "",
        ip: 0,
        inst: ${steps},
        done: false,
    }`}
>
    <span class="inline-block bg-[var(--code-theme-bg-acolor)] px-2 rounded-tl rounded-tr font-mono text-sm">thp code</span>
    <pre class="language-thp" style="margin: 0; border-top-left-radius: 0;" data-disabled><code set:html={codeHtml}></code></pre>
    <div class="grid grid-cols-2 font-mono text-sm">
        <div>
            <div class="p-1 border-b border-r border-white">stdout</div>
            <div class="h-24 p-1 border-r border-white">
                <code class="bg-black" x-text="stdout"></code>
            </div>
        </div>
        <div>
            <div class="p-1 border-b border-white">state</div>
            <div class="h-24 p-1">
                x = 20
            </div>
        </div>
    </div>
    <div class="border-t border-white p-1">
        <button class="font-mono px-1 rounded bg-pink-950" @click="alpineNext($data)" :disabled="done && 'true'">
            Step
        </button>
    </div>
</div>

<script>
    type Instruction = "line" ;
    type AlpineState = {
        line: number,
        stdout: string,
        ip: number,
        inst: Array<Array<[Instruction, number]>>
        done: boolean,
    }

    /// Executes the instruction following the state of the machine.
    function alpineNext(data: AlpineState) {
        const len = data.inst.length;
        const ip = data.ip;
        data.ip += 1;

        const instructions = data.inst[ip]!;
        for (const instructionSet of instructions) {
            const instructionArr = instructionSet;
            switch (instructionArr[0]) {
                case "line": {
                    data.line = Number(instructionArr[1]);
                    break;
                }
            }
        }

        if (data.ip >= len) {
            console.log("done");
            data.done = true;
            return;
        }
    }
    // @ts-ignore
    window.alpineNext = alpineNext;
</script>
