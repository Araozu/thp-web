---
layout: ../../../layouts/PagesLayout.astro
title: Try/Exceptions
---
import InteractiveCode from "../../../components/InteractiveCode.astro";

# Try/exceptions

Unlike PHP, in THP all errors must be explicitly declared
and handled.

## Declare that a function returns an exception

To declare a possible error return value the `Result` enum
is used.

For example, a function that returned a `DivisionByZero`
may be written like this:

```thp
fun invert(Int number) -> Int!DivisionByZero
{
    if number == 0
    {
        return DivisionByZero()
    }

    return 1 / number
}
```

In the previous segment, `Int!DivisionByZero` denotates
that the function may return either an `Int` or an `DivisionByZero`.

We then can return the error or success value;


### Multiple error returns

TODO: fix?



If there are multiple error types that the function can return,
you can use the `|` operator:

```thp
type Exceptions = Exception1 | Exception2 | Exception3

fun sample() -> Int!Exceptions
{ /* ... */}
```



## Error handling

The caller must handle all possible errors, they don't automatically
bubble up the stack.

THP provides syntax for handling errors following certain patterns,
via try expressions:

### Naked try

Use a naked `try` when you want to rethrow an error, if there is any.

<InteractiveCode 
    code={`
    fun dangerous() -> Int!Exception
    {   // May throw randomly
        return if Math.random() < 0.5 { 50 }
        else { Exception("Unlucky") }
    }

    fun run() -> !Exception
    {   // If \`dangerous()\` throws, the function exits with the same error.
        // Otherwise, continues
        val result = try dangerous()
        print("The result is {result}")
    }

    val res1 = run() // First, without error
    val res2 = run() // Then, an example with error
    `}
    steps={`[
        [["line", 14]],
        [["line", 7]],
        [
            ["line", 10],
            ["set", "Int result", "..."]
        ],
        [["line", 1]],
        [["line", 3]],
        [
            ["line", 10],
            ["set", "Int result", "Int 50"]
        ],
        [["line", 11]],
        [
            ["line", 14],
            ["out", "The result is 50\\n"],
            ["unset", "Int result"],
        ],
        [
            ["line", 15],
            ["set", "res1", "<empty>"],
        ],
        [["line", 7]],
        [["line", 10]],
        [["line", 1]],
        [["line", 3]],
        [["line", 4]],
        [
            ["line", 10],
            ["set", "result", "Exception(\\"Unlucky\\")"]
        ],
        [["line", 15]],
        [
            ["line", 0,],
            ["set", "res2", "Exception(\\"Unlucky\\")"],
        ]
    ]`}
></InteractiveCode>


In the previous example:

- If `dangerous()` returns an `Exception`, this exception
    will be returned by `run()`;
- If `dangerous()` succeedes, its value is assigned
    to `result`, and the function continues executing.


### Try/return

Try/return will return a new value if an expression fails,
otherwise will assign the success value and continue.

Try/return will run a function and assign its value if `Ok` is found.
Otherwise, it will return a new value specified by the programmer.

```thp
fun run() -> Int
{
    val result = try dangerous() return 0

    // ...
}
```

In the previous example:

- If `dangerous()` fails, its error will be ignored, and `0` will
    be returned from `run()`.
- If `dangerous()` succeedes, its value will be assigned to `result`,
    and the function continues executing.


### Try/else

Try/return will assign a new value if an expression fails.

```thp
fun run()
{
    val result = try dangerous() else 322

    print(result)
}
```

- If `dangerous()` fails, the value `322` will be assigned to `result`.
- If `dangerous()` succeedes, its value will be assigned to `result`.

Either way, the function will continue executing.


### Try/catch

Try/catch allows the error to be manually used & handled.


```thp
fun run()
{
    val result = try dangerous()
    catch Exception e
    {
        // This is run if `dangerous()` throws.
        // `e` is the thrown error

        // Handle the error
        // ...

        // Return a new value to be assigned to `result`
        0
    }
}
```

A try/catch may have many `catch` clauses:

```thp
try dangerous()
catch Exception1 e
{...}
catch Exception2 e
{...}
catch Exception3 e
{...}
```


